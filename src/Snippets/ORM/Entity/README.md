## Класс `\Bitrix\Main\ORM\Entity`

### Содержимое
- Общая информация
- Класс `Book`
- Класс `BookCollection`
- Класс `BookFactory`
- Класс `BookRepository`
- Пример использования.

#### Общая информация
Bitrix ORM очень тесно завязана на использовании класса `\Bitrix\Main\ORM\Data\DataManager`. Проблема этого класса заключается в том,
что все его методы являются статическими. Статические методы плохи тем, что они вводят понятие "Глобального состояния" для клиентского кода.
Глобальное состояние не позволяет вносить расширения, так как, грубо говоря, в коде библиотеки жестко задано имя класса, метод которого используется.
Битрикс всячески пытается обойти эту проблему тем, что динамически определяет наименование текущего наследника от `DataManager` перед тем, как вызвать его методы.
К сожалению, такой подход не сработает в случае, если возникнет необходимость написания автотестов для классов клиентского кода.
Наряду с `DataManager`, Битрикс также часто оперирует с `Entity`, который имеет огромное количество неявных зависимостей от `DataManager`.
Целью данного сниппета является демонстрация возможных способов работы с Bitrix ORM только с помощью класса `Entity`.

#### Класс `Book`
Представляет собой пассивную сущность, содержащую в себе два поля: `ID` и `NAME`.
Пассивная сущность по своему определению является неизменяемой, поэтому вместо классических сеттеров имеет методы `with*`.
Такие методы не изменяют текущий экземпляр сущности, а клонируют его и уже у клона меняют определенные значения.
Возвращаемым результатом также будет не оригинальная сущность, а её клон.

#### Класс `BookCollection`
Представляет собой пассивную коллекцию сущностей `Book`; позволяет добавлять и убирать элементы из своего содержимого.
Используется для поддержания неизменяемости для группы элементов, полученной в результате выборки из `Persistence`.
Методы `with*` и `without*` порождают новый экземпляр сущности с помощью клонирования текущего экземпляра.

#### Класс `BookFactory`
Предназначен для реализации шаблона проектирования `Абстрактная фабрика`. 
Динамически порождает экземпляры класса `\Bitrix\Main\ORM\Entity` и `\Bitrix\Main\ORM\Query\Query`.
Даёт возможность реализовать различные алгоритмы порождения данных объектов, что крайне полезно при юнит тестировании.

#### Класс `BookRepository`
Предназначен для формирования конкретных запросов к `Persistence` для взаимодействия с состоянием `Book`.
Имеет зависимостью `BookFactory`. Задает конечный набор методов манипуляции данными; грубо говоря, каждый метод этого класса отображает конкретный запрос к БД.
Для `DDL` запросов использует пустой экземпляр `EntityObject`, который заполняет данными из сущности `Book`.
Для `SELECT ...` запросов использует `EntityObject` и `Collection`, но их вывод все равно преобразует в соответствующие им `Book` и `BookCollection`.
В `SELECT ...` запросах не принципиально использование `EntityObject` и `Collection`, обычного `fetch` должно быть достаточно; в данном сниппете это сделано для сохранения единообразия кодовой базы.

#### Пример использования

```php
<?php


use Snippets\ORM\Entity\Book;
use Snippets\ORM\Entity\BookRepository;
use Snippets\ORM\Entity\BookFactory;


// Подготовка зависимостей.
$factory = new BookFactory();
$repository = new BookRepository($factory);

// Создание нового экземпляра.
$bible = new Book(null, 'Holy Bible');
$bookId = $repository->add($bible);

// Получение только что созданного экземпляра из БД.
$book = $repository->findById($bookId);

// Проверка значений.
assert($book->getName() === $bible->getName());
```